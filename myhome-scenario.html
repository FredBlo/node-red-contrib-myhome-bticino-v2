<script type="text/javascript">
  RED.nodes.registerType('myhome-scenario',{
    category: 'Bticino MyHome',
    color: '#a6bbcf',
    defaults: {
      name: { value: '', required: true },
      scenarioid: { value: '', required: true, validate: RED.validators.number() },
      scenariotype: { value: 'CEN+', required: true },
      topic: { value: '', required: true},
      gateway: { type: 'myhome-gateway', required: true },
      skipevents: { value: false, required: false },
      rules: {value:[{
        buttonFrom: 0,
        buttonTo: 31,
        onStartPress:false,
        onEndShortPress:true,
        onEndLongPress:true,
        onDuringLongPress:false,
        minLongPressDuration:1000
      }]},
      outputs: {value:1}
    },
    inputs: 1,
    inputLabels: function () {
      let inputLabel = "simple mode ('payload' or 'payload.state') 'xx(:yyyy)':";
      inputLabel += "\n - 'xx' buttonID (0-31)                                              ";
      inputLabel += "\n - 'yyyy' -optional- duration in ms                         ";
      return inputLabel;
    },
    outputs: 1,
    outputLabels: function(index) {
      let rule = this.rules[index-1];
      let label = '';
      if (rule) {
        if (rule.buttonFrom == rule.buttonTo) {
          label = 'button #' + rule.buttonFrom;
        } else {
          label = 'buttons #' + rule.buttonFrom + ' to #' + rule.buttonTo;
        }
        let onEvents = [];
        if (rule.onStartPress) {
          onEvents.push (' - Start press');
        }
        if (rule.onEndShortPress) {
          onEvents.push (' - Short press');
        }
        if (rule.onEndLongPress) {
          onEvents.push (' - Long press (>' + (rule.minLongPressDuration/1000).toFixed(1).toString() + 's)');
        }
        if (rule.onDuringLongPress) {
          onEvents.push (' - Long press (while pressed)');
        }
        if (onEvents.length) {
          label += ' on :' + '\n' + onEvents.join ('\n');
        }
      } else {
        label = 'Main payload';
      }
      return label;
    },
    icon: 'font-awesome/fa-magic',
    paletteLabel: 'MH Scenario',
    label: function() {
      return this.name || 'MH Scenario';
    },
    oneditprepare: function() {
      $(document).on('change', '#node-input-topic', function() {
        let infoVar = $('#node-input-topic').val();
        let infoMsg = "to trigger the action on this node, do not forget the incoming 'msg' MUST contain a 'msg.topic' which is either 'state/" + infoVar + "' (when used in read-only mode) "
        + "or 'cmd/" + infoVar + "' (when used in write mode), otherwise node will skip incoming message.";
        $('#node-info-topic').prop('title' , infoMsg);
      });

      // When scenario type is changed from CEN <> CEN+, update labels for 'Start press'
      $(document).on('change', '#node-input-scenariotype', function() {
        let onStartLabel = '';
        if ($("#node-input-scenariotype").val() === "CEN") {
          onStartLabel = 'Start short/long press';
        } else {
          onStartLabel = 'Start long press';
        }
        let rules = $("#node-input-rule-container").editableList('items');
        rules.each (function (i) {
            let rule = $(this);
            rule.find("label[for='node-input-onStartPress_" + i + "']").text(onStartLabel);
        });
      });

      // Styles used in rules container
      $("style").append("#node-input-rule-container .mhrule-fromtolabel {display:inline-block; width:100px; margin-left: 20px;}");
      $("style").append("#node-input-rule-container .mhrule-checkbox {display:inline-block; width:22px; margin-left:0px; vertical-align:baseline;}");
      $("style").append("#node-input-rule-container .mhrule-select {width:60px; height: 23px; padding: 2px 2px; margin-left: 25px; margin-right: 35px; text-align: center;}");
      $("style").append("#node-input-rule-container .mhrule-checkbox-label {width: auto; margin-bottom: 2px;}");

      $("#node-input-rule-container").css('min-height','300px').css('min-width','450px').editableList({
        addButton: 'add new buttons range',
        header: $("<div style='background:#EFEFEF; display:grid; grid-template-columns:135px 1fr 90px 30px'>"
            +"<div style='margin-left: 30px; display: inline-grid; margin-top: 5px; font-weight:bold'>Buttons range...</div>"
            +"<div style='display: inline-grid; margin-top: 5px; font-weight:bold'>Trigger a new flow on...</div>"
            +"<div style='display: inline-grid; justify-self: end; margin-top: 5px; font-weight:bold'>Output nÂ°</div>"
            +"</div>"),

        addItem: function (container, i, rules) {
          if (!rules.hasOwnProperty('rule')) {
            rules.rule = {};
          }
          var rule = rules.rule;
          // When object is new, apply default values
          if (!rule.hasOwnProperty('buttonFrom')) {
            rule.buttonFrom = '0';
          }
          if (!rule.hasOwnProperty('buttonTo')) {
            rule.buttonTo = '31';
          }
          if (!rule.hasOwnProperty('onEndShortPress')) {
            rule.onEndShortPress = true;
          }
          if (!rule.hasOwnProperty('onEndLongPress')) {
            rule.onEndLongPress = true;
          }
          if (!rule.hasOwnProperty('minLongPressDuration')) {
            rule.minLongPressDuration = 1000;
          }
          let uniqueRowID = Math.floor(10000000*Math.random()).toString();
          // ROW 1
          let row1 = $('<div/>').appendTo(container);
          row1.append('<span class="mhrule-fromtolabel">From...</span>');
          let field_onStartPress = $('<input/>',{id:"node-input-onStartPress_" + uniqueRowID,type:"checkbox", class:"mhrule-checkbox"}).appendTo(row1);
          row1.append('<label class="mhrule-checkbox-label" for="node-input-onStartPress_' + uniqueRowID + '">Start press</label>');
          // ROW1 : output info (rightest part)
          let finalspan = $('<span/>',{style:"float: right;margin-top: 6px;"}).appendTo(row1);
          finalspan.append('<i class="fa fa-sign-out"></i><span class="node-input-rule-index">'+(i+2)+'</span>');
          // ROW 2
          let row2 = $('<div/>').appendTo(container);
          let field_buttonFrom = $('<select/>',{id:"node-input-buttonFrom_" + uniqueRowID, class:"mhrule-select"}).appendTo(row2);
          let field_onEndShortPress = $('<input/>',{id:"node-input-onEndShortPress_" + uniqueRowID, type:"checkbox", class:"mhrule-checkbox"}).appendTo(row2);
          row2.append('<label class="mhrule-checkbox-label" for="node-input-onEndShortPress_' + uniqueRowID + '">Short press ended (<0.5s)</label>');
          // ROW 3
          let row3 = $('<div/>').appendTo(container);
          row3.append('<span class="mhrule-fromtolabel">To...</span>');
          let field_onEndLongPress = $('<input/>',{id:"node-input-onEndLongPress_" + uniqueRowID, type:"checkbox", class:"mhrule-checkbox"}).appendTo(row3);
          row3.append('<label class="mhrule-checkbox-label" for="node-input-onEndLongPress_' + uniqueRowID + '" style="width:unset";>Long press ended when >&nbsp</label>');
          let field_minLongPressDuration = $('<input/>',{id:"node-input-minLongPressDuration_" + uniqueRowID, type:"text",style:"height:23px; width:55px; padding: 2px 2px;"}).appendTo(row3);
          row3.append('<label class="mhrule-checkbox-label" for="node-input-minLongPressDuration_' + uniqueRowID + '">&nbsp ms</label>');
          // ROW 4
          let row4 = $('<div/>').appendTo(container);
          let field_buttonTo = $('<select/>',{id:"node-input-buttonTo_" + uniqueRowID, class:"mhrule-select"}).appendTo(row4);
          let field_onDuringLongPress = $('<input/>',{id:"node-input-onDuringLongPress_" + uniqueRowID, type:"checkbox", class:"mhrule-checkbox"}).appendTo(row4);
          row4.append('<label class="mhrule-checkbox-label" for="node-input-onDuringLongPress_' + uniqueRowID + '">Long press (while pressed)</label>');

          // Build all 0-31 choices to both fields inputs
          for (let i = 0; i <= 31; i++) {
            field_buttonFrom.append($("<option></option>").val(i.toString()).text(i.toString()));
            field_buttonTo.append($("<option></option>").val(i.toString()).text(i.toString()));
          }

          // Events : When From & To selector is changed, ensure range remains OK
          field_buttonFrom.on ("change", function() {
            if (parseInt(field_buttonFrom.val()) > parseInt(field_buttonTo.val())) {
              field_buttonTo.val(field_buttonFrom.val());
            }
          });
          field_buttonTo.on ("change", function() {
            if (parseInt(field_buttonFrom.val()) > parseInt(field_buttonTo.val())) {
              field_buttonFrom.val(field_buttonTo.val());
            }
          });

          // Copy memory info back on fields
          field_buttonFrom.val (rule.buttonFrom.toString());
          field_buttonTo.val (rule.buttonTo.toString());
          field_minLongPressDuration.val (rule.minLongPressDuration.toString());
          // Checkboxes
          field_onStartPress.prop ('checked', rule.onStartPress);
          field_onEndShortPress.prop ('checked', rule.onEndShortPress);
          field_onEndLongPress.prop ('checked', rule.onEndLongPress);
          field_onDuringLongPress.prop ('checked', rule.onDuringLongPress);
          // Update total number of outputs (Primary is 1 + 1 per rule defined)
          $("#node-input-outputs").val(i+2);
        },
        removeItem: function (rule) {
          // Re-parse all remaining rules to re-number them in UI
          let rules = $("#node-input-rule-container").editableList('items');
          rules.each(function(i) {
            $(this).find(".node-input-rule-index").html(i+2);
          });
          // Update total number of outputs (Primary is 1 + 1 per rule defined)
          $("#node-input-outputs").val(rules.length+1);
        },
        sortItems: function (rules) {
          // Re-parse all remaining rules to re-number them in UI
          rules.each(function(i) {
            $(this).find(".node-input-rule-index").html(i+2);
          });
        },
        sortable: true,
        removable: true
      });

      // Add all previously saved rules back to UI List
      for (let i = 0 ; i < this.rules.length ; i++) {
        $("#node-input-rule-container").editableList('addItem',{rule:this.rules[i], i:i});
      }
    },

    oneditresize: function(size) {
        let rows = $("#dialog-form>div:not(.node-input-rule-container-row)");
        let height = size.height;
        for (let i = 0 ; i<rows.length ; i++) {
            height -= $(rows[i]).outerHeight(true);
        }
        let editorRow = $("#dialog-form>div.node-input-rule-container-row");
        height -= (parseInt(editorRow.css("marginTop"))+parseInt(editorRow.css("marginBottom")));
        height += 16;
        $("#node-input-rule-container").editableList('height',height);
    },

    oneditsave: function() {
      let rules = $("#node-input-rule-container").editableList('items');
      let node = this;
      node.rules = [];
      rules.each (function (i) {
        let rule = $(this);
        let savedRule = {};
        savedRule.buttonFrom = parseInt(rule.find("[id^=node-input-buttonFrom_]").val());
        savedRule.buttonTo = parseInt(rule.find("[id^=node-input-buttonTo_]").val());
        savedRule.onStartPress = rule.find("[id^=node-input-onStartPress_]").prop("checked");
        savedRule.onEndShortPress = rule.find("[id^=node-input-onEndShortPress_]").prop("checked");
        savedRule.onEndLongPress = rule.find("[id^=node-input-onEndLongPress_]").prop("checked");
        savedRule.onDuringLongPress = rule.find("[id^=node-input-onDuringLongPress_]").prop("checked");
        savedRule.minLongPressDuration = parseInt(rule.find("[id^=node-input-minLongPressDuration_]").val());
        node.rules.push (savedRule);
      });
    }
  });
</script>

<script type="text/x-red" data-template-name="myhome-scenario">
  <div class="form-row">
    <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Scenario name" />
  </div>
  <div class="form-row">
    <label for="node-input-scenarioid"><i class="fa fa-magic"></i> Scenario</label>
    <div style="display: inline-block; position: relative; width: 70%; height: 20px;">
      <select id="node-input-scenariotype" style="width:80px">
        <option value="CEN">CEN</option>
        <option value="CEN+">CEN+</option>
      </select>
      <div style="position: absolute; left: 85px; right: 0px; top:0px;">
        <input type="text" id="node-input-scenarioid" style="width:100%" placeholder="32 (for CEN 3.2) or 126 (for CEN+ 126)" />
      </div>
    </div>
  </div>
  <div class="form-row">
      <label for="node-input-topic"><i class="fa fa-terminal"></i> Topic</label>
      <input type="text" id="node-input-topic" placeholder="e.g. firstfloor-office" />
      &nbsp;<i id="node-info-topic" class="fa fa-info-circle" title=""></i>
  </div>
  <div class="form-row">
      <label for="node-input-gateway"><i class="fa fa-server"></i> Gateway</label>
      <input type="text" id="node-input-gateway" />
  </div>
  <div class="form-row">
      <label for="node-input-skipevents"><i class="fa fa-ban"></i> Skip events</label>
      <label for="node-input-skipevents" style="width:70%">
        <input type="checkbox" id="node-input-skipevents" style="display:inline-block; margin-left:0px; width:22px; vertical-align:baseline;" />Skip incoming events from gateway
        &nbsp;<i class="fa fa-info-circle" title="If necessary, all MyHome status updates received from the gateway about this node can be ignored, which means only Node-RED received payloads will be processed."></i>
      </label>
  </div>
  <div class="form-row">
    <i class="fa fa-sign-out"></i> <b>Additional outputs...</b>
  </div>
  <div class="form-row node-input-rule-container-row" style="width:100%">
    <input type="hidden" id="node-input-outputs"/>
    <ol id="node-input-rule-container"></ol>
  </div>
</script>



name: { value: '', required: true },
scenarioid: { value: '', required: true, validate: RED.validators.number() },
scenariotype: { value: 'CEN+', required: true },
topic: { value: '', required: true},
gateway: { type: 'myhome-gateway', required: true },
skipevents: { value: false, required: false },
rules: {value:[{
  buttonFrom: 0,
  buttonTo: 31,
  onStartPress:false,
  onEndShortPress:true,
  onEndLongPress:true,
  onDuringLongPress:false,
  minLongPressDuration:1000
}]},

<script type="text/x-red" data-help-name="myhome-scenario">
  <p>Adds a MyHome Scenario Node to your flow.</p>
  <ul>
    <li><strong>Name</strong> (mandatory) is the name of the node</li>
    <li><strong>Scenario</strong> defines the ID of the scenario, based on its type :
      <ul>
        <li><strong>CEN</strong> : A/PL number ('A=1 PL=5' becomes '15', also be aware the format is 4 digits when A>9 or PL>9, e.g. 'A=11 PL=5' becomes `1105`, 'A=1 PL=15' becomes '0115')</li>
        <li><strong>CEN+</strong> : scenario number (0-2047)</li>
      </ul>
    </li>
    <li><strong>Topic</strong> is used on received payload to trigger the action on the node (see info in inputs definition)</li>
    <li><strong>Gateway</strong> is the gateway to be configured in order to connect to MyHome system</li>
    <li><strong>Skip incoming events from gateway</strong> : when enabled, all MyHome status updates received from the gateway about this node will be ignored, which means only Node-RED received payloads will be processed.</li>
    <li><strong>Rules</strong> : you can define different rules based on your needs. Each rule will output to a separate additional output.
      <ul>
        <li><strong>Buttons range</strong> : Defines which button(s) must be monitored to trigger a new flow. Defaults to 0-31, meaning the largest possible buttons range. </li>
        <li><strong>Action type</strong> : Defines on which type of button press a flow must be started :
          <ul>
            <li><i>On start press</i> : when button is initially pressed. Note that the behaviour is a bit different based on scenario type. For CEN, this event is always triggered, even for a short press, while for CEN+, this event only occurs when a long press is started.</li>
            <li><i>On short press end</i> : when button was pressed for less than <strong>0.5s</strong>.</li>
            <li><i>On long press end (after xx ms)</i> : when button was pressed for at least <strong>0.5s</strong>. You can also define your own minimal duration before flow must be triggered.</li>
            <li><i>On long press (while pressed)</i> : as long as button remains pressed, the BUS will emit such an event approximatively every 500ms</li>
          </ul>
        </li>
        <p>Note : if an event occurs (i.e. button press) which matches multiple rules you defined, multiple flows will be started too.</p>
      </ul>
    </li>
  </ul>

<h3>Inputs</h3>
<p><code>msg.payload</code> can be of 2 types</p>
  <ul>
    <li>A simple <em>string</em> value : <code>xx(:yyyy)</code>
      <ul>
        <li><code>xx</code> : the button number (0-31) to virtually press</li>
        <li><code>yyyy</code> : the duration (ms) button must remain virtually pressed. Is optional, defaults to 0 if omitted, meaning a short press</li>
      </ul>
    </li>
    <li>An <em>Object</em> with properties :
      <ul>
        <li> <code>payload.buttonID</code> <em>[string/number]</em> the button number (0-31) to virtually press</li>
        <li> <code>payload.actionDuration</code> <em>[string/number]</em> the duration (ms) button must remain virtually pressed. Is optional, defaults to 0 if omitted, meaning a short press
        </li>
        <li> <code>payload.state</code> <em>[string]</em> (optional) when both <code>.buttonID</code> and <code>.actionDuration</code> are omitted, is tested for string content 'xx(:yyyy)' as described above for a simple input</li>
      </ul>
    </li>
    <i>Note : Technically, for long press, repeat commands are sent every 400 ms to virtually keep button 'pressed'. This means a deviation can (and will) occur when comparing the requested time to the effective applied duration (e.g. when applying a duration of 900ms to node, it will make 3x 400, meaning 1200ms).</i>
  </ul>
<p><code>msg.topic</code> is required to trigger the node action: received <code>msg.topic</code> must be set to <code>cmd/xxxx</code> where xxxx is the value defined as Topic in node configuration.</p>

<h3>Outputs</h3>
<p>The <strong>primary output</strong> is a JSON object <code>msg.payload</code> with</p>
  <ul>
    <li> <code>payload.buttonsLastState_xx</code> <em>[object]</em> where xx is the button ID (0-31), meaning returned payload will contain one object per button for which at least one command was received since Node-RED was started. Each object will contain :
      <ul>
        <li> <code>.buttonID</code> <em>[number]</em> the button number (0-31)</li>
        <li> <code>.state</code> <em>[string]</em> summarizes the information about button last state in a simplified form <code>xx:mmmm(:yyyy)</code> where :
          <ul>
            <li><code>xx</code> : button number (0-31)</li>
            <li><code>mmmm</code> : action type, can be 'PRESS_START' / 'LONG_START' / 'LONG_ONGOING' / 'SHORT' / 'LONG'</li>
            <li><code>yyyy</code> : -only in long pressed mode- duration (ms) button remained (virtually) pressed</li>
          </ul>
        </li>
        <li> <code>.actionStart</code> <em>[date-time]</em> the date-time when button when last pressed (start of press)</li>
        <li> <code>.actionEnd</code> <em>[date-time]</em> the date-time when button when last pressed (end of press)</li>
        <li> <code>.actionDuration</code> <em>[number]</em> the duration (ms) button was pressed</li>
        <li> <code>.countExtPressures</code> <em>[number]</em> (only in long press mode) the number of repeat commands received on the bus while button was pressed</li>
        <li> <code>payload.state</code> <em>[string]</em> (optional) when both <code>.buttonID</code> and <code>.actionDuration</code> are omitted, is tested for string content 'xx(:yyyy)' as described above for a simple input</li>
      </ul>
      <i>Note : all properties of <strong>last pressed button</strong> are also directly included as direct properties of payload itself, allowing direct access to those without having to parse the button sub-object.</i>
    </li>
    <li> <code>payload.command_sent</code> <em>[array of string]</em> when the node was triggered from Node-RED (i.e. commands were sent to the MyHome gateway), contains the commands which were sent in OpenWebNet protocol (e.g. <em>'*25*21#8*2100##'</em> to short press button 8 of scenarion CEN+ 100)</li>
    <li> <code>payload.command_received</code> <em>[string]</em> when the node was triggered from the gateway (i.e. a command was detected on the MyHome BUS for the configured scenario), contains the command which was read in OpenWebNet protocol (ex: <em>'*25*24#14*287##'</em> means button 14 of scenario 87 finalized a long press)</li>
    <li> <code>payload.command_responses</code> <em>[array of strings]</em> when the node was triggered from Node-RED in read-only mode, will contain the returned response(s) from the MyHome BUS in OpenWebNet protocol</li>
    <li> <code>payload.command_failed</code> <em>[array of strings]</em> will contain the commands which were refused by the MyHome gateway, in OpenWebNet protocol</li>
  </ul>
  <p>Any <strong>additional output</strong> defined is also a JSON object <code>msg.payload</code> having the same (direct) properties as a <code>payload.buttonsLastState_xx</code> object described above.</p>
</script>
